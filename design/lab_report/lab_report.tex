%!Mode:: "TeX:UTF-8"
\documentclass[a4paper,11pt,UTF8]{ctexart}

\usepackage{indentfirst} %缩进
\usepackage{xeCJK}    %使用系统字体
\usepackage{fancyhdr} %自定义页眉页脚
\pagestyle{empty}                   %不设置页眉页脚
\usepackage{amsmath, amsthm, amssymb, amsfonts} %数学公式
\usepackage[a4paper,left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
%\usepackage[tmargin=1in,bmargin=1in,lmargin=1.25in,rmargin=1.25in]{geometry}.
\usepackage{booktabs} %插入表格
\usepackage[section]{placeins} %避免浮动
\usepackage{listings} %插入代码
\usepackage{ctex}     %中文宏包
\usepackage[svgnames, table]{xcolor} %彩色表格
\usepackage{algorithm}          %伪代码
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{algorithm,algpseudocode,float}
\usepackage{lipsum}
\usepackage{enumitem}           %调整列举环境
\usepackage{url}
\usepackage{fontspec,xunicode}
\usepackage{subfigure}
\usepackage{parskip}      %m行n列图片排版方法
\defaultfontfeatures{Mapping=tex-text} %如果没有它，会有一些 tex 特殊字符无法正常使用，比如连字符。

\usepackage{graphicx}
\graphicspath{{imgs/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 缩进及行间距
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setlength{\parindent}{22pt} %重新定义缩进长度
\setlength{\baselineskip}{20pt}  %定义行间距
%\renewcommand{\baselinestretch}{1.1} %定义行间距

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 列表设置
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setenumerate{fullwidth,itemindent=\parindent,listparindent=\parindent,itemsep=0ex,partopsep=0pt,parsep=0ex}
\setenumerate[2]{label=\alph*),leftmargin=1.5em}  %二级item设置
\setitemize{itemindent=38pt,leftmargin=0pt,itemsep=-0.4ex,listparindent=26pt,partopsep=0pt,parsep=0.5ex,topsep=-0.25ex}
\setdescription{itemindent=38pt,leftmargin=0pt,itemsep=-0.4ex,listparindent=26pt,partopsep=0pt,parsep=0.5ex,topsep=-0.25ex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 图的标题行间距设置
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\bottomcaption}{%
\setlength{\abovecaptionskip}{6pt}%
\setlength{\belowcaptionskip}{6pt}%
\caption}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 字体定义
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setmainfont{Times New Roman}  %默认英文字体.serif是有衬线字体sans serif无衬线字体
\setmonofont{FiraCode-Retina.ttf}
\setCJKmainfont[ItalicFont={楷体}, BoldFont={黑体}]{宋体}%衬线字体 缺省中文字体为
\setCJKsansfont{黑体}
\punctstyle{hangmobanjiao}
%-----------------------xeCJK下设置中文字体------------------------------%
\setCJKfamilyfont{song}{SimSun}                             %宋体 song
\newcommand{\song}{\CJKfamily{song}}
\setCJKfamilyfont{fs}{FangSong}                      %仿宋  fs
\newcommand{\fs}{\CJKfamily{fs}}
\setCJKfamilyfont{ktgb}{KaiTi}                      %楷体2312 ktgb
\newcommand{\ktgb}{\CJKfamily{ktgb}}
\setCJKfamilyfont{yh}{Microsoft YaHei}                    %微软雅黑 yh
\newcommand{\yh}{\CJKfamily{yh}}
\setCJKfamilyfont{hei}{SimHei}                              %黑体  hei
\newcommand{\hei}{\CJKfamily{hei}}
\setCJKfamilyfont{hwxk}{STXingkai}                                %华文行楷  hwxk
\newcommand{\hwxk}{\CJKfamily{hwxk}}
%------------------------------设置字体大小------------------------%
\newcommand{\shiyanbaogao}{\fontsize{36pt}{\baselineskip}\selectfont}
\newcommand{\chuhao}{\fontsize{42pt}{\baselineskip}\selectfont}     %初号
\newcommand{\xiaochuhao}{\fontsize{36pt}{\baselineskip}\selectfont} %小初号
\newcommand{\yihao}{\fontsize{28pt}{\baselineskip}\selectfont}      %一号
\newcommand{\erhao}{\fontsize{21pt}{\baselineskip}\selectfont}      %二号
\newcommand{\xiaoerhao}{\fontsize{18pt}{\baselineskip}\selectfont}  %小二号
\newcommand{\sanhao}{\fontsize{15.75pt}{\baselineskip}\selectfont}  %三号
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}       %四号
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  %小四号
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    %五号
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   %小五号
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  %六号
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    %七号

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 图题字体大小相同
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{caption}
\captionsetup{font={footnotesize}}   % footnotesize = 9pt
\captionsetup[lstlisting]{font={footnotesize}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 重定义枚举编号为 1),2)...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\labelenumi}{\theenumi)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 重定义section标题
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\CTEXsetup[format={\sihao\CJKfamily{zhhei}\zihao{4}},number={\chinese{section}},name={,、~},aftername={},indent={0pt},beforeskip={6pt},afterskip={6pt},format+={\flushleft}]{section}
\CTEXsetup[format={\Large\bfseries\CJKfamily{zhkai}\zihao{5}},name={（,）},number={\chinese{subsection}},aftername={},indent={22pt},beforeskip={14pt},afterskip={2pt}]{subsection}
\CTEXsetup[number={\chinese{section}},name={附录, ~~ }]{appendix}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 标题名称中文化
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand\figurename{\hei 图}
\renewcommand\tablename{\hei 表}
\renewcommand\lstlistingname{\hei 代码}
\renewcommand{\algorithmicrequire}{\textbf{输入:}}
\renewcommand{\algorithmicensure}{\textbf{输出:}}
\newtheorem{define}{定义}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 代码设置
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstset{
 columns=fixed,
 numbers=left,                                        % 在左侧显示行号
 numberstyle=\tiny\color{gray},                       % 设定行号格式
 frame=single,                                      % 单线背景边框
%  frame=none,                                          % 不显示背景边框
 breaklines=true,                                     % 设定LaTeX对过长的代码行进行自动换行
 tabsize=4,                                           % 把tab扩展为4个空格，默认是8个太长
 keywordstyle=\color[RGB]{40,40,255},                 % 设定关键字颜色
 numberstyle=\footnotesize\color{darkgray}\ttfamily,
 commentstyle=\it\color[RGB]{0,96,96}\ttfamily,       % 设置代码注释的格式
 stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},   % 设置字符串格式
 showstringspaces=false,                              % 不显示字符串中的空格
 language=c++,                                        % 设置语言
 basicstyle=\linespread{0.7}\xiaowuhao\ttfamily,                      % 字体字号
 morekeywords={alignas,continute,friend,register,true,alignof,decltype,goto,
 reinterpret_cast,try,asm,defult,if,return,typedef,auto,delete,inline,short,
 typeid,bool,do,int,signed,typename,break,double,long,sizeof,union,case,
 dynamic_cast,mutable,static,unsigned,catch,else,namespace,static_assert,using,
 char,enum,new,static_cast,virtual,char16_t,char32_t,explict,noexcept,struct,
 void,export,nullptr,switch,volatile,class,extern,operator,template,wchar_t,
 const,false,private,this,while,constexpr,float,protected,thread_local,
 const_cast,for,public,throw,std},
 xleftmargin=2em,
 xrightmargin=2em,
 aboveskip=1em
 %lineskip=10pt,
 %baselinestretch=1,
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 伪代码分页
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter
\renewcommand{\ALG@name}{算法}
\newenvironment{breakablealgorithm}
  {% \begin{breakablealgorithm}
   \begin{center}
     \refstepcounter{algorithm}% New algorithm
     \hrule height.8pt depth0pt \kern2pt% \@fs@pre for \@fs@ruled
     \renewcommand{\caption}[2][\relax]{% Make a new \caption
       {\raggedright\textbf{\ALG@name~\thealgorithm} ##2\par}%
       \ifx\relax##1\relax % #1 is \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}%
       \else % #1 is not \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}%
       \fi
       \kern2pt\hrule\kern2pt
     }
  }{% \end{breakablealgorithm}
     \kern2pt\hrule\relax% \@fs@post for \@fs@ruled
   \end{center}
  }
\makeatother



\begin{document}
\xiaosihao\song

\begin{titlepage}
\center{\yihao{\hwxk{南京航空航天大学}}}
\vspace{6cm}
\center{\shiyanbaogao{\ktgb{数~据~结~构~课~程~设~计}}}
\vspace{4cm}

\begin{center}
\begin{large}
\begin{tabular}{rc}
  \xiaoerhao{\hei{班\qquad 级}}& \hspace{1.7cm}\xiaoerhao{\hei{1819001\hspace{1.7cm}}} \\
  \cline{2-2}\\
  \xiaoerhao{\hei{学\qquad 号}}& \hspace{1.7cm}\xiaoerhao{\hei{161940233\hspace{1.7cm}}} \\
  \cline{2-2}\\
  \xiaoerhao{\hei{姓\qquad 名}}& \xiaoerhao{\hei{颜~宇~明}}\\
  \cline{2-2}\\
  \xiaoerhao{\hei{指导教师}}& \xiaoerhao{\hei{秦~小~麟}}\\
  \cline{2-2}
\end{tabular}
\end{large}
\end{center}
\vfill \hfill
\end{titlepage}
\clearpage


% \centerline{\\[10pt]\erhao{\fs{目~~录}}}
\tableofcontents
\newpage
\section{区块链}
\subsection{数据结构}
链表
\subsection{算法设计思想}
将区块设计成链表节点，每增加一个节点，计算校验码都要结合之前所有的节点的信息。
\subsection{源程序}
\begin{lstlisting}[caption=Linked\_list.h,captionpos=b]
#ifndef LINKED_LIST_H
#define LINKED_LIST_H
class ADT_list{
public:
    typedef struct node
    {
        int number;
        char information[100];
        int Checkcode;
        node *next;
    } node;
    node *head;
    int length = -1;

    void InitLIst();
    void DestoryList();
    void ClearList();
    bool ListEmpty();
    int ListLength();
    node* GetElem(int);
    int LocateElem(int);
    int PriorElem(int);
    int NextElem(int);
    void ListTraverse();
    void CreateList(char*, int);
    int CheckList();
    void SetStr(int, const char*);
    void InsertElem(char*);
    int GetCheckcode();
    void DeleteElem(int index);
    void Reverse();
};
#endif
\end{lstlisting}

\begin{lstlisting}[caption=Linked\_list.cpp,captionpos=b]
  #include <malloc.h>
  #include <stdio.h>
  #include <string.h>
  #include "Linked_list.h"

  void ADT_list::InitLIst(){
      node *tmp = (node *)malloc(sizeof(node));
      length = 0;
      head = tmp;
      tmp->next = NULL;
  }

  void ADT_list::DestoryList(){
      node *p, *temp;
      p = head;
      while (p != NULL){
          temp = p;
          p = p->next;
          free(temp);
      }
      length = -1;
  }

  void ADT_list::ClearList(){
      node *p, *temp;
      p = head->next;
      while (p != NULL){
          temp = p;
          p = p->next;
          free(temp);
      }
      length = 0;
      head->next = NULL;
  }

  bool ADT_list::ListEmpty(){
      if (length < 1) return true;
      return false;
  }

  int ADT_list::ListLength(){
      return length;
  }

  ADT_list::node* ADT_list::GetElem(int index){
      node *p;
      int i = 0;
      p = head->next;
      while (p != NULL){
          if (index == ++i)
              return p;
          p = p->next;
      }
      return NULL;
  }

  int ADT_list::LocateElem(int num){
      node *p;
      p = head->next;
      int index = 0;
      while (p != NULL){
          if (p->number == num)
              return index;
          p = p->next;
          index++;
      }
      return -1;
  }

  int ADT_list::PriorElem(int cur_num){
      node *p, *temp;
      p = head->next;
      while (p != NULL){
          temp = p;
          p = p->next;
          if (p != NULL && p->number == cur_num)
              return temp->number;
      }
      return 0;
  }

  int ADT_list::NextElem(int cur_num){
      node *p, *temp;
      p = head->next;
      while (p != NULL){
          temp = p;
          p = p->next;
          if (p != NULL && temp->number == cur_num)
              return p->number;
      }
      return 0;
  }

  void ADT_list::ListTraverse(){
      node *p;
      p = head->next;
      puts("Block Chain Output:");
      while (p != NULL){
          printf("%d %s %d\n", p->number, p->information, p->Checkcode);
          p = p->next;
      }
      printf("\n");
  }

  void ADT_list::CreateList(char* str, int check){
      node *p = head;
      while (p->next != NULL) p = p->next;
      node *tmp = (node *)malloc(sizeof(node));
      p->next = tmp;
      tmp->next = NULL;
      tmp->number = length;
      strcpy(tmp->information, str);
      length++;
      tmp->Checkcode = check;
  }

  int ADT_list::CheckList(){
      node* p = head->next, *tmp = p;
      if (!p) return 1;
      while(p) {
          int sum = 0;
          for (int i = 0; i < strlen(p->information); i++)
              sum += p->information[i];
          if (p->number) {
              node *temp = head;
              sum += p->number;
              while (temp->next != p) temp = temp->next;
              sum += temp->Checkcode;
          }
          // printf("%d %d %d\n", sum % 113, p->Checkcode, p->number);
          if (sum % 113 != p->Checkcode) return p->number + 100;
          p = p->next;
      }
      return 1;
  }

  void ADT_list::SetStr(int index, const char* str){
      node *p;
      int i = 0;
      p = head->next;
      while (p && index != i++) p = p->next;
      strcpy(p->information, str);
      while(p) {
          int sum = 0;
          for (int i = 0; i < strlen(p->information); i++)
              sum += p->information[i];
          if (p->number) {
              node *temp = head;
              sum += p->number;
              while (temp->next != p) temp = temp->next;
              sum += temp->Checkcode;
          }
          // printf("%d %d %d\n", sum % 113, p->Checkcode, p->number);
          // if (sum % 113 != p->Checkcode) return p->number + 100;
          p->Checkcode = sum % 113;
          p = p->next;
      }
  }

  void ADT_list::InsertElem(char* str){
      node *p = head;
      while (p->next != NULL) p = p->next;
      node *tmp = (node *)malloc(sizeof(node));
      p->next = tmp;
      tmp->next = NULL;
      tmp->number = length;
      strcpy(tmp->information, str);
      length++;
      tmp->Checkcode = GetCheckcode();
  }
  int ADT_list::GetCheckcode(){
      node* p = head;
      while (p->next != NULL) p = p->next;
      int sum = 0;
      for (int i = 0; i < strlen(p->information); i++)
          sum += p->information[i];
      if (length > 1) {
          sum += p->number;
          p = head;
          while (p->next->next) p = p->next;
          sum += p->Checkcode;
      }
      return sum % 113;
  }
  void ADT_list::DeleteElem(int index){
      node *p, *temp;
      int i = 0;
      temp = head;
      p = head->next;
      length--;
      while (p != NULL){
          if (index != ++i) {
              temp = p;
              p = p->next;
              continue;
          }
          temp->next = p->next;
          free(p);
      }
  }

  void ADT_list::Reverse(){
      if (length < 1) return;
      node *p, *temp, *tmp = NULL;
      temp = p = head->next;
      while(temp != NULL){
          temp = p->next;
          p->next = tmp;
          tmp = p;
          p = temp;
      }
      head->next = tmp;
  }
  \end{lstlisting}
\begin{lstlisting}[caption=main.cpp,captionpos=b]
    #include <stdio.h>
    #include "Linked_list.h"
    char str[100];
    int num, check;
    int main(){
        ADT_list list;
        list.InitLIst();
        freopen("insertnode", "r", stdin);
        while (scanf("%s", &str) != EOF) list.InsertElem(str);
        list.ListTraverse();
        list.ClearList();
        freopen("CheckBlockChain", "r", stdin);
        while (scanf("%s%d", &str, &check) != EOF) list.CreateList(str, check);
        list.ListTraverse();
        (num = list.CheckList()) < 100 ? puts("Accept!") : printf("The %dth node Error!\n\n", num - 100);
        list.SetStr(1, "22");
        list.ListTraverse();

    }
\end{lstlisting}
\subsection{测试数据及其结果}
文件insertnode创建区块链输入：
\begin{lstlisting}
    3
    2
    1
\end{lstlisting}

文件CheckBlockChain创建一个错误的区块链：
\begin{lstlisting}
    3 51
    2 102
    1 4
\end{lstlisting}

main.cpp输出为：
\begin{lstlisting}
    Block Chain Output:
    0 3 51
    1 2 102
    2 1 40

    Block Chain Output:
    0 3 51
    1 2 102
    2 1 4

    The 2th node Error!

    Block Chain Output:
    0 3 51
    1 22 39
    2 1 90
\end{lstlisting}

由以上输出结果可知，题目要求所有完全达到了。

\subsection{时间复杂度}
$$
O(n)
$$
\subsection{改进方法}
算校验码不需要每次都把前面所有的节点都遍历一遍，可以直接用最后一个节点的校验码。

\section{迷宫问题}

\subsection{数据结构}
用栈来实现深度优先搜索
\subsection{算法设计思想}
先生成迷宫，设定起点，然后用栈实现的深度优先搜索来寻找迷宫的出口，迷宫保证路径唯一。
\subsection{源程序}

\begin{lstlisting}[caption=main.cpp,captionpos=b]
#include <stdio.h>
#include <stdlib.h>
#include "Sequence_Stack.h"
#include <fstream>
using namespace std;
int maze[100][100], n, visited[100][100];
int xx[] = {-1, 1, 0, 0};
int yy[] = {0, 0, -1, 1};
int endx, endy, flag;
ADT_Stack Stack;
string temp;
int main(){
    ifstream ReadFile("maze");
    while(getline(ReadFile, temp)) n++;

    Stack.InitStack();
    freopen("maze", "r", stdin);
    for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++)
        scanf("%d", &maze[i][j]);
    for (int i = n; i >= 1; i--)
        if (!maze[i][n]) endx = i, endy = n;

    Pos *point = new Pos;
    point->x = 2;
    point->y = 1;
    point->last = NULL;
    Stack.Push(*point);
    visited[point->x][point->y] = 1;
    while (Stack.rear) {
        Pos pp = Stack.Pop();
        Pos *p = new Pos;
        p->x = pp.x;
        p->y = pp.y;
        p->last = pp.last;
        visited[p->x][p->y] = 1;
        if (p->x == endx && p->y == endy) {
            point = p;
            while (point)
                maze[point->x][point->y] = 2, point = point->last;

            for (int i = 0; i <= n; i++) {
                for (int j = 0; j <= n; j++) {
                    if (maze[i][j] == 0)
                        printf("  ");
                    else if (maze[i][j] == 2)
                        printf("██");
                    else
                        printf("░░");
                }
                printf("\n");
            }
            return 0;
        }
        for (int i = 0; i < 4; i++)
            if (!maze[p->x + xx[i]][p->y + yy[i]] && !visited[p->x + xx[i]][p->y + yy[i]]) {
                point = new Pos;
                point->x = p->x + xx[i];
                point->y = p->y + yy[i];
                point->last = p;
                Stack.Push(*point);
            }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption=MazeGeneration.cpp,captionpos=b]
#include<stdio.h>
#include<fstream>
#include<Windows.h>
#include<time.h>
#include<math.h>

//地图长度L，包括迷宫主体40，外侧的包围的墙体2，最外侧包围路径2（之后会解释）
#define L 44

//墙和路径的标识
#define WALL  0
#define ROUTE 1
using namespace std;
//控制迷宫的复杂度，数值越大复杂度越低，最小值为0
static int Rank = 0;
int startx = 2, starty = 1;

//生成迷宫
void CreateMaze(int **maze, int x, int y);

int main(void) {
    srand((unsigned)time(NULL));

    int **Maze = (int**)malloc(L * sizeof(int *));
    for (int i = 0; i < L; i++) {
        Maze[i] = (int*)calloc(L, sizeof(int));
    }

    //最外围层设为路径的原因，为了防止挖路时挖出边界，同时为了保护迷宫主体外的一圈墙体被挖穿
    for (int i = 0; i < L; i++){
        Maze[i][0] = ROUTE;
        Maze[0][i] = ROUTE;
        Maze[i][L - 1] = ROUTE;
        Maze[L - 1][i] = ROUTE;
    }

    //创造迷宫，（2，2）为起点
    CreateMaze(Maze, startx, starty + 1);

    //画迷宫的入口和出口
    Maze[2][1] = ROUTE;

    //由于算法随机性，出口有一定概率不在（L-3,L-2）处，此时需要寻找出口
    for (int i = L - 3; i >= 0; i--) {
        if (Maze[i][L - 3] == ROUTE) {
            Maze[i][L - 2] = ROUTE;
            break;
        }
    }

    //画迷宫
    for (int i = 0; i < L; i++) {
        for (int j = 0; j < L; j++) {
            if (Maze[i][j] == ROUTE) {
                printf("  ");
            }
            else {
                printf("██");
            }
        }
        printf("\n");
    }
    ofstream out("maze");
    if (out.is_open()){
        for (int i = 1; i < L - 1; i++) {
            for (int j = 1; j < L - 1; j++) {
                if (Maze[i][j] == ROUTE)
                    out << "0 ";
                else
                    out << "1 ";
            }
            out << "\n";
        }
    }

    for (int i = 0; i < L; i++) free(Maze[i]);
    free(Maze);

    return 0;
}

void CreateMaze(int **maze, int x, int y) {
    maze[x][y] = ROUTE;

    //确保四个方向随机
    int direction[4][2] = { { 1,0 },{ -1,0 },{ 0,1 },{ 0,-1 } };
    for (int i = 0; i < 4; i++) {
        int r = rand() % 4;
        int temp = direction[0][0];
        direction[0][0] = direction[r][0];
        direction[r][0] = temp;

        temp = direction[0][1];
        direction[0][1] = direction[r][1];
        direction[r][1] = temp;
    }

    //向四个方向开挖
    for (int i = 0; i < 4; i++) {
        int dx = x;
        int dy = y;

        //控制挖的距离，由Rank来调整大小
        int range = 1 + (Rank == 0 ? 0 : rand() % Rank);
        while (range>0) {
            dx += direction[i][0];
            dy += direction[i][1];

            //排除掉回头路
            if (maze[dx][dy] == ROUTE) {
                break;
            }

            //判断是否挖穿路径
            int count = 0;
            for (int j = dx - 1; j < dx + 2; j++) {
                for (int k = dy - 1; k < dy + 2; k++) {
                    //abs(j - dx) + abs(k - dy) == 1 确保只判断九宫格的四个特定位置
                    if (abs(j - dx) + abs(k - dy) == 1 && maze[j][k] == ROUTE) {
                        count++;
                    }
                }
            }

            if (count > 1) {
                break;
            }

            //确保不会挖穿时，前进
            --range;
            maze[dx][dy] = ROUTE;
        }

        //没有挖穿危险，以此为节点递归
        if (range <= 0) {
            CreateMaze(maze, dx, dy);
        }
    }
}
\end{lstlisting}


\begin{lstlisting}[caption=Sequence\_Stack.h,captionpos=b]
#ifndef SEQUENCE_Stack_H
#define SEQUENCE_Stack_H
typedef struct Pos
{
    int x;
    int y;
    Pos *last;
} Pos;
class ADT_Stack{
public:
    Pos Stack[9999];
    int rear = -1;
    void InitStack();
    void DestoryStack();
    void ClearStack();
    bool StackEmpty();
    int StackLength();
    Pos GetTop();
    void StackTraverse();
    void Push(Pos);
    Pos Pop();
    Pos operator [] (int);
    // int LocateElem(int num);
    // int PriorElem(int cur_num);
    // int NextElem(int cur_num);
    // int SetElem(int index, int num);
    // void InsertElem(int index, int num);
    // void DeleteElem(int index);
    // void Remove();
    // void Bubble_Sort();
    // void Select_sort();
    // ADT_Stack Union(ADT_Stack);
    // void Josephus(int);
};
#endif
\end{lstlisting}

\begin{lstlisting}[caption=Makefile, captionpos=b]
CC = g++

OUT1 = MazeGeneration.exe
OBJ1 = MazeGeneration.o

OUT2 = main.exe
OBJ2 = main.o Sequence_Stack.o

IN = main.cpp MazeGeneration.cpp Sequence_Stack.cpp

build: $(OUT1) $(OUT2)

run: $(OUT1) $(OUT2)
    @./$(OUT1);./$(OUT2)

clean:
    @rm -f *.o $(OUT1) $(OUT2)

$(OUT1): $(OBJ1)
    @$(CC) $(OBJ1) -o $(OUT1)

$(OUT2): $(OBJ2)
    @$(CC) $(OBJ2) -o $(OUT2)

$(OBJ): $(IN)
    @$(CC) -c $(IN)
\end{lstlisting}

\subsection{测试数据及其结果}

在项目目录下运行命令：
\begin{lstlisting}
    clear;make clean;make run
\end{lstlisting}

运行结果为：

\begin{figure}[htbp] % h为当前位置，!htb为忽略美学标准，htbp为浮动图形
    \centering
    \subfigure[自动生成的迷宫]{
        \includegraphics[width=2.5in]{1.png}
        }
        \subfigure[基于DFS的迷宫路径可视化]{
        \includegraphics[width=2.5in]{2.png}
        }
        \caption{实验结果}
    \end{figure}

    由以上结果可知，实现题目的全部要求。

\subsection{时间复杂度}
$$
O(n^2)
$$
\subsection{改进方法}
可以尝试用Dijkstra算法来解决这个问题。
\section{JSON查找}

\subsection{数据结构}
\subsection{算法设计思想}
\subsection{源程序}
\subsection{测试数据及其结果}
\subsection{时间复杂度}
\subsection{改进方法}

\section{公交线路提示}
\subsection{数据结构}
栈，队列，邻接矩阵，Dijkstra算法，广度优先搜索
\subsection{算法设计思想}

\begin{enumerate}
   \item 最短路径：利用邻接矩阵Dijkstra算法，计算两点之间的最短路径。
   \item 最少转乘：采用广度优先遍历算法，判断起点所涉及的每辆公交车经过的所有站点，如果有终点，则无需转车。若无终点，则让起点所涉及的每辆公交车经过的所有站点进入队列，通过Visited数组判断该站点是否已经访问过。队列元素出队，继续判断该点所涉及的每辆公交车经过的所有站点，重复以上步骤，直至找到所需终点。
\end{enumerate}\par

\subsection{源程序}
\begin{lstlisting}[caption=BusRoute.cpp,captionpos=b]
#include <map>
#include <list>
#include <queue>
#include <string>
#include <vector>
#include <fstream>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
#define INF 0x3f3f3f3f
#define maxn 40000

vector<string> split(const string& str, const string& delim) {
    vector<string> res;
    if("" == str) return res;
    //先将要切割的字符串从string类型转换为char*类型
    char * strs = new char[str.length() + 1];
    strcpy(strs, str.c_str());

    char * d = new char[delim.length() + 1];
    strcpy(d, delim.c_str());

    char *p = strtok(strs, d);
    while(p) {
        string s = p; //分割得到的字符串转换为string类型
        res.push_back(s); //存入结果数组
        p = strtok(NULL, d);
    }
    return res;
}

class FindKey
{
private:
    int num;
public:
    FindKey(int n) :num(n){}
    bool operator ()(map<string, int>::value_type item){
        return item.second == num;
    }
};

class BusStationDatabase
{
    private:
        typedef struct Pos
        {
            int StationNum;
            int BusNum;
            Pos *last;
        } Pos;

        list<string> stations;
        int StationNumber;
        int RouteNumber;
        int StartStaionNum;
        map<string, int> StationMap;           //站点及其编号的映射
        map<int, vector<string> > BusInfo;     //第几路公交车及其经过站点的映射
        map<string, vector<int> > StationInfo; //每个站点都有哪些公交车经过
        queue<Pos> Queue;

        struct Edge{
            int v;
            int len;
            int next;
        } edge[111111];
        int head[maxn], cnt = 0;
        int from, to;
        string start, end;
        int visit[maxn];
        int dis[maxn], path[maxn];


    public:
        BusStationDatabase(){
            StationNumber = 1;
            RouteNumber = 0;
        }
        void LoadData(){
            ifstream inputfile("NanjingBusRoute");
            if(inputfile.fail()){
                cout<<"Open failed."<<endl;
                inputfile.close();
                return;
            }
            string input_line;
            while(!inputfile.eof()){
                getline(inputfile, input_line);
                vector<string> splitarr = split(input_line, "   ");
                splitarr[0].pop_back();
                vector<string> curBusStation = split(splitarr[1], ",");
                BusInfo[stoi(splitarr[0])] = curBusStation;
                for (auto i : curBusStation){
                    auto key = StationMap.find(i);
                    if (key == StationMap.end())
                        StationMap[i] = StationNumber++;
                    StationInfo[i].push_back(stoi(splitarr[0]));
                }
            }
            inputfile.close();
            StationNumber--;
            RouteNumber = BusInfo.size();
            return;
        }
        void BuildGraph(){
            for (auto i : BusInfo) {
                for(int j = 0; j < i.second.size() - 1; j++){
                    from = StationMap[i.second[j]];
                    to = StationMap[i.second[j + 1]];
                    addedge(from, to, 1);
                    addedge(to, from, 1);
                }
            }
        }
        void PrintLeastStationRoute(int s){
            if (!s) return;
            PrintLeastStationRoute(path[s]);
            auto it = find_if(StationMap.begin(), StationMap.end(), FindKey(s));
            if (it != StationMap.end())
                if (path[s])
                    cout << "->" << (*it).first;
                else
                    cout << (*it).first;
        }
        void LeastStationRoute(){
            freopen("StartEndStation", "r", stdin);
            cin >> start >> end;
            memset(path, 0, sizeof(path));
            memset(visit, 0, sizeof(visit));
            int flag = 0;
            auto key = StationMap.find(start);
            if (key == StationMap.end()) flag = 1;
            key = StationMap.find(end);
            if (key == StationMap.end()) flag = 1;
            if (flag) {
                cout << "error!" << endl;
                return;
            }
            dijkstra();
            for (int i = 1; i <= StationNumber; i++)
                if (i == StationMap[end]) {
                    cout << "经过站点最少: " << dis[i] << "站" << endl;
                    int p = path[i];
                    PrintLeastStationRoute(i);
                    cout << endl << endl;
                }
        }
        void LeastChangeRoute(){
            memset(path, 0, sizeof(path));
            memset(visit, 0, sizeof(visit));
            Pos *point = new Pos;
            point->BusNum = 0;
            point->last = NULL;
            point->StationNum = StationMap[start];
            Queue.push(*point);
            visit[point->StationNum] = 1;
            while (!Queue.empty()) {
                Pos front = Queue.front();
                Queue.pop();
                Pos *p = new Pos;
                p->StationNum = front.StationNum;
                p->BusNum = front.BusNum;
                p->last = front.last;
                visit[p->StationNum] = 1;
                if (p->StationNum == StationMap[end]) {
                    point = ReverseList(p);
                    point->BusNum = point->last->BusNum;
                    cout << "转车次数最少: " << endl;
                    while (point->last){
                        int tmp = point->StationNum;
                        auto ss = find_if(StationMap.begin(), StationMap.end(), FindKey(tmp));
                        auto ee = find_if(StationMap.begin(), StationMap.end(), FindKey(point->last->StationNum));
                        auto StartStation = find(BusInfo[point->last->BusNum].begin(), BusInfo[point->last->BusNum].end(), (*ss).first);
                        auto EndStation = find(BusInfo[point->last->BusNum].begin(), BusInfo[point->last->BusNum].end(), (*ee).first);
                        if (StartStation > EndStation) reverse(BusInfo[point->last->BusNum].begin(), BusInfo[point->last->BusNum].end());
                        int flag = 0;
                        for (auto i : BusInfo[point->last->BusNum]) {
                            if (i == (*ss).first || flag) {
                                if (i == (*ee).first){
                                    cout << i << "(" << point->last->BusNum << "路)";
                                    break;
                                }
                                cout << i << "(" << point->last->BusNum << "路)->";
                                flag = 1;
                            }
                        }
                        if (point->last->last) cout << endl << "转" << endl;
                        point = point->last;
                    }
                    return;
                }
                auto StationName = find_if(StationMap.begin(), StationMap.end(), FindKey(p->StationNum));
                for (auto i : StationInfo[(*StationName).first]) { //能经过该站点所有公交车的列表
                    for (auto j : BusInfo[i]) { // 该公交车经过的所有站点列表
                        if (!visit[StationMap[j]]) { //如果这个站点没有被访问过，就加到队列里
                            point = new Pos;
                            point->StationNum = StationMap[j];
                            point->BusNum = i;
                            point->last = p;
                            Queue.push(*point);
                        }
                    }
                }
            }
        }
        Pos* ReverseList(Pos *root){
            Pos *p, *temp, *tmp = NULL;
            temp = p = root;
            while(temp){
                temp = p->last;
                p->last = tmp;
                tmp = p;
                p = temp;
            }
            return tmp;
        }
        void addedge(int from, int to, int len){
            edge[++cnt].v = to;
            edge[cnt].len = len;
            edge[cnt].next = head[from];
            head[from] = cnt;
        }
        void dijkstra(){
            for (int i = 1; i <= StationNumber; i++)
                dis[i] = INF;
            int temp = StationMap[start];
            dis[temp] = 0;
            int minn;
            while (!visit[temp]){
                visit[temp] = 1;
                for (int j = head[temp]; j; j = edge[j].next)
                    if (!visit[edge[j].v] && dis[edge[j].v] > dis[temp] + edge[j].len)
                        dis[edge[j].v] = dis[temp] + edge[j].len, path[edge[j].v] = temp;
                minn = INF;
                for (int j = 1; j <= StationNumber; j++)
                    if (!visit[j] && minn > dis[j])
                        minn = dis[j], temp = j;
            }
        }
        int get_StationNumber(){return StationNumber;}
        int get_route_number(){return RouteNumber;}
        list<string>& get_station_name_list(){return stations;}
};
BusStationDatabase lib;
int main()
{
    lib.LoadData();
    lib.BuildGraph();
    lib.LeastStationRoute();
    lib.LeastChangeRoute();
    return 0;
}
\end{lstlisting}
\subsection{测试数据及其结果}
起点：干休所站 \par
终点：墨香路站
\begin{lstlisting}[caption=测试用例1,captionpos=b]
经过站点最少: 10站
干休所站->河路道站->中央门北站->中央门东站->龙蟠路南京站西站->龙蟠路南京站东站->新庄广场南站->长途东站站->樱铁村站->经五立交站->墨香路站

转车次数最少:
干休所站(1路)->河路道站(1路)->中央门北站(1路)->中央门南站(1路)
转
中央门南站(22路)->中央门东站(22路)->龙蟠路南京站西站(22路)->龙蟠路南京站东站(22路)->新庄广场西站(22路)->新庄广场北站(22路)->曹后村站(22路)->江南公交一公司站(22路)->红山森林动物园站(22路)->十字街站(22路)->省中西医结合医院站(22路)->红山路
迈皋桥站(22路)->华电路站(22路)->长营村站(22路)->北苑新村站(22路)->月苑小区站(22路)->月苑南路站(22路)->墨香路站(22路)
\end{lstlisting}

起点：干休所站 \par
终点：国际青年文化中心站
\begin{lstlisting}[caption=测试用例2,captionpos=b]
经过站点最少: 24站
干休所站->河路道站->中央门北站->中央门南站->许府巷站->玄武湖公园站->中央路鼓楼
站->中山路珠江路北站->新街口南站->三元巷站->中山南路升州路站->中华路瞻园路站->
钓鱼台站->窑湾街站->雨花西路站->能仁里站->龙福山庄站->秋叶村站->梦都大街庐山路
站->庐山路牡丹江街站->庐山路奥体大街站->庐山路中央公园站->庐山路嘉陵江东街站->
江东中路江山大街站->国际青年文化中心站

转车次数最少:
干休所站(25路)->河路道站(25路)->中央门北站站(25路)->中央门南站站(25路)->许府巷
站(25路)->玄武湖公园站(25路)->中山路鼓楼站(25路)->鼓楼医院站(25路)->中山路珠江
路南站(25路)->新街口东站(25路)->大行宫西站(25路)->大行宫东站(25路)->中山东路逸
仙桥(毗卢寺)站(25路)->西安门站(25路)->瑞金北村站(25路)->瑞金路站(25路)
转
瑞金路站(7路)->解放南路站(7路)->大光路站(7路)->通济门站(7路)->建康路大中桥站(7
路)->建康路夫子庙站(7路)->升州路三山街站(7路)->评事街站(7路)->水西门站(7路)->莫
愁湖公园南门站(7路)->水西门大街大士茶亭站(7路)->茶亭东街站(7路)->江东门纪念馆站
(7路)->水西门大街江东门站(7路)->江东万达广场站(7路)->江东中路集庆门大街站(7路)->江东中路应天大街站(7路)->江东中路月安街站(7路)->江东中路兴隆大街站(7路)->兴隆
大街燕山路站(7路)->清竹园南门站(7路)->兴隆大街华山路站(7路)->乐山路梦都大街站(7路)->金陵图书馆站(7路)->奥体中心西门站(7路)->乐山路富春江西街站(7路)->乐山路楠
溪江西街站(7路)->乐山路河西大街站(7路)->乐山路白龙江西街站(7路)->乐山路仁恒江湾
城站(7路)->乐山路金沙江西街站(7路)->青年文化中心东门站(7路)->国际青年文化中心站
(7路)
\end{lstlisting}

\subsection{时间复杂度}
\begin{enumerate}
   \item Dijkstra算法时间复杂度：$$O(V^2)$$
   \item 广度优先搜索时间复杂度：$$O(V)$$
\end{enumerate}\par

\subsection{改进方法}
由于节点太多，转乘3次以上会导致广度优先搜索是速度变慢，可以使用减少不必要的步骤，来减少时间开销。

\section{Hash表应用}
\subsection{数据结构}
\subsection{算法设计思想}
\subsection{源程序}
\subsection{测试数据及其结果}
\subsection{时间复杂度}
\subsection{改进方法}

\section{排序算法比较}
\subsection{数据结构}
各种排序算法，都是数组。
\subsection{算法设计思想}

\begin{enumerate}
	\item 直接插入排序：将一条记录插入到已排好的有序表中，从而得到一个新的、记录数量增1的有序表。
	\item 希尔排序：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。
	\item 冒泡排序：依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。
	\item 快速排序：挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。
	\item 选择排序：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。 以此类推，直到全部待排序的数据元素的个数为零。
	\item 堆排序：利用堆这种数据结构所设计的一种排序算法。 堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
	\item 归并排序：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 若将两个有序表合并成一个有序表，称为二路归并。
	\item 基数排序：将整数按位数切割成不同的数字，然后按每个位数分别比较。具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。
\end{enumerate}\par

\subsection{源程序}

\begin{lstlisting}[caption=Sort.cpp,captionpos=b]

\end{lstlisting}

\begin{lstlisting}[caption=NumGeneration.cpp,captionpos=b]
#include <stdio.h>
#include <iostream>
#include <fstream>
#include <time.h>
using namespace std;
int num = 50000, n, a = num;
int main(void) {
    srand((unsigned)time(NULL));
    ofstream out("1Sample");
    while (num)
        out << a - num-- << endl;
    out.close();

    out.open("2Sample");
    num = a;
    while (num--) out << num << endl;
    out.close();

    num = 10;
    for (int i = 3; i <= num; i++){
        out.open(to_string(i) + "Sample");
        n = a;
        while (n--)
            out << rand() % a << endl;
        out.close();
    }
    return 0;
}
\end{lstlisting}

\begin{lstlisting}[caption=Makefile,captionpos=b]
CC = g++
SOURCE := NumGeneration.cpp Sort.cpp

build:
    @$(foreach var,$(SOURCE),\
        $(CC) -c $(var); \
        $(CC) $(subst .cpp,.o,$(var)) -o $(subst .cpp,.exe,$(var)); \
        ./$(subst .cpp,.exe,$(var));\
    )

clean:
    @rm -f *.o *.exe *Sample
\end{lstlisting}

\subsection{测试数据及其结果}

测试数据用NumGeneration.cpp生成10个每个含有50000个元素的样本。

\begin{lstlisting}[caption=结果,captionpos=b]
          Insert   Shell  Bubble  Select    Heap   Merge   Radix  Insert
1Sample:  0.000s  0.003s  3.064s  2.685s  0.010s  0.000s  0.015s
2Sample:  4.707s  0.003s  5.329s  2.825s  0.009s  0.004s  0.004s
3Sample:  2.413s  0.010s  7.257s  2.761s  0.011s  0.007s  0.004s
4Sample:  2.793s  0.010s  7.300s  2.763s  0.011s  0.007s  0.004s
5Sample:  2.566s  0.011s  7.392s  2.733s  0.011s  0.007s  0.004s
6Sample:  2.472s  0.010s  7.217s  2.662s  0.012s  0.007s  0.004s
7Sample:  2.367s  0.010s  6.910s  2.611s  0.011s  0.006s  0.004s
8Sample:  2.302s  0.010s  6.812s  2.656s  0.011s  0.006s  0.003s
9Sample:  2.412s  0.011s  7.042s  2.717s  0.011s  0.007s  0.004s
10Sample: 2.337s  0.010s  7.519s  2.815s  0.016s  0.008s  0.005s
\end{lstlisting}

\subsection{时间复杂度}

\begin{figure}[htbp] % h为当前位置，!htb为忽略美学标准，htbp为浮动图形
    \centering
    \includegraphics[width=13cm]{3.jpg}
    \caption{排序算法比较}
\end{figure}

\subsection{改进方法}

每种排序算法都是固定的，不需要改进。

\section{总结}
\subsection{代码行数}
\begin{table}[!h!tbp]
    \centering
  \begin{tabular*}{0.75\textwidth}{@{\extracolsep{\fill}}lcc}
      \toprule
      题目          &行数         \\
      \midrule
      区块链         &283     \\
      迷宫问题       &388     \\
      JSON查找      &$\times$    \\
      \bottomrule
  \end{tabular*}
  \end{table}
  总代码行数为：1000.
\subsection{心得体会}

\setlength{\parskip}{6pt}  %定义段间距
\vspace{4cm}
\end{document}
